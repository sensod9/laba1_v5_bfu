#include <iostream>
#include <cmath>

int main()
{
	double fBound, sBound, result; 
	/* действительная числовая ось включает целые и нецелые числа, 
		 поэтому представить можно через тип с плавающей точкой 
	   (не использую long double, тк макс. и мин. значение зависят от комплитора + пришлось бы возиться с памятью для подсчёта макс. значения, ведь было бы переполнение по выведенной мной формуле) 
	*/

	int bE = 11, bM = 52; // кол-во бит на экспоненту и мантиссу соответственно
	std::cout << "double, double; " << sizeof(double)*8 << " bits; max: " << powl(2, powl(2, bE - 1)) - powl(2, (powl(2, bE - 1) - 1) - bM) << "; min: " << -(powl(2, powl(2, bE - 1)) - powl(2, (powl(2, bE - 1) - 1) - bM)) << std::endl;
	// 2^(2^(bE - 1)) - 2^((2^(bE - 1) - 1) - bM), где bE - кол-во бит на экспоненту; bM - кол-во бит на мантиссу

	/* макс. число, представленное через double имеет следующий вид в битах:
		 0111111111101111111111111111111111111111111111111111111111111111
		 ^знак      ^завершающий бит экспоненты
		 если все биты экспоненты были бы единицами, то число представлялось бы как NaN

		 итого: 64 бита в общем; 1 бит на знак; 11 бит на экспоненту, при этом последний бит 0; 52 бита на мантиссу
		 
		 формула для подсчёта: (-1)^S * 1.M * 10^E,
		 											 где s = 0, если знак положительный; s = 1, если знак отрицательный;
													 		 M - мантисса без завершающий нулей; E = экспонента минус 01111111111 (для представления минусовых степеней)

		(-1)^0 * 1.(52 единицы) * 10^(11111111110 - 01111111111)
		1.(52 единицы) * 10^1023
		53 единицы и 1023 - 52 = 971 нолей
		приведём число из 53 единиц и 971 нолей подряд в десятичный вид
		(2^(53+971) - 1) - (2^971 - 1) = 2^1024 - 2^971 = примерно 1.79769 * 10^308
		
		получаем общую формулу:
		2^((bM + 1) + (2^(bE - 1) - 1) - bM) - 2^((2^(bE - 1) - 1) - bM)
		или же 2^(2^(bE - 1)) - 2^((2^(bE - 1) - 1) - bM), где bE - кол-во бит на экспоненту; bM - кол-во бит на мантиссу
	 	
		круто получилось. если подставить bM и bE для float, то всё так же корректно посчитается.
		а вообще есть же ещё inf и -inf, которые представлены так же через double, так что настоящее макс. значение inf, а мин. -inf :)
	*/

	std::cin >> fBound >> sBound;
	result = fBound/2 + sBound/2; 
	std::cout << "double: " << result << std::endl;


	/* inf -inf nan 1.79769e+308 -1.79769e+308
	uint64_t ibits = 0b0111111111110000000000000000000000000000000000000000000000000000,
					 mbits = 0b1111111111110000000000000000000000000000000000000000000000000000,
					 nbits = 0b0111111111111111111111111111111111111111111111111111111111111111,
					 maxbits = 0b0111111111101111111111111111111111111111111111111111111111111111,
					 minbits = 0b1111111111101111111111111111111111111111111111111111111111111111;
	double infinite, minfinite, notan, maximum, minimum;
	memcpy(&infinite, &ibits, sizeof(double));
	memcpy(&minfinite, &mbits, sizeof(double));
	memcpy(&notan, &nbits, sizeof(double));
	memcpy(&maximum, &maxbits, sizeof(double));
	memcpy(&minimum, &minbits, sizeof(double));
	std::cout << infinite << " " << minfinite << " " << notan << " " << maximum << " " << minimum << std::endl;
	*/

	return 0;
}